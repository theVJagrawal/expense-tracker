# Expense Tracker

A production-minded expense tracking application built with Spring Boot and React, focusing on correctness, idempotency, and clean architecture.

## Overview

This is a minimal but production-ready expense tracker that demonstrates real-world engineering practices under time constraints. The system uses in-memory storage instead of a database due to timeboxing, but is designed to easily support persistent storage in the future.

**Key Features:**
- ✅ Idempotent expense creation (safe under retries, refreshes, and network failures)
- ✅ Decimal-safe money handling using BigDecimal (no floating-point errors)
- ✅ Category filtering and date-based sorting
- ✅ Real-time expense totals
- ✅ Clean separation of concerns (Controller → Service → Storage)
- ✅ Thread-safe concurrent operations
- ✅ Input validation with clear error messages

**Tech Stack:**
- **Backend:** Java 17, Spring Boot 3.2, Maven
- **Frontend:** React 18, Vite
- **Storage:** In-memory (ConcurrentHashMap + CopyOnWriteArrayList)

---

## Key Design Decisions

### 1. Idempotent POST using `clientRequestId`

**Problem:** Network retries, slow responses, and multiple button clicks can create duplicate expenses.

**Solution:** Every expense creation request includes a `clientRequestId` generated by the client. The backend checks if this ID already exists before creating a new expense.

**Implementation:**

**Frontend (React):**
```javascript
// Generate ID once per logical submission
const clientRequestIdRef = useRef(null);

if (!clientRequestIdRef.current) {
  clientRequestIdRef.current = generateClientRequestId();
}

// Use same ID for retries
const expenseData = {
  amount: 100.50,
  category: "Food",
  clientRequestId: clientRequestIdRef.current  // Reused on retry
};
```

**Backend (Spring Boot):**
```java
public Expense createExpense(CreateExpenseRequest request) {
    // Check for existing expense (idempotency)
    return storage.findByClientRequestId(request.getClientRequestId())
            .orElseGet(() -> {
                // Only create if not found
                Expense expense = Expense.builder()
                    .id(UUID.randomUUID().toString())
                    .clientRequestId(request.getClientRequestId())
                    // ... other fields
                    .build();
                return storage.save(expense);
            });
}
```

**Storage:**
```java
// ConcurrentHashMap provides O(1) lookup + thread safety
private final Map<String, Expense> idempotencyMap = new ConcurrentHashMap<>();

public synchronized Expense save(Expense expense) {
    // Double-check pattern for race condition protection
    Expense existing = idempotencyMap.get(expense.getClientRequestId());
    if (existing != null) {
        return existing;
    }
    
    idempotencyMap.put(expense.getClientRequestId(), expense);
    expenses.add(expense);
    return expense;
}
```

**Benefits:**
- ✅ Same request (same `clientRequestId`) returns same expense
- ✅ Multiple submit clicks → single expense
- ✅ Page refresh during submission → no duplicate
- ✅ Network retry → no duplicate

---

### 2. Decimal-Safe Money Handling

**Problem:** Float and Double types lose precision in decimal arithmetic:
```java
// WRONG - Float/Double lose precision
double total = 0.1 + 0.2;  // = 0.30000000000000004 ❌
```

**Solution:** Use `BigDecimal` for all monetary values.

```java
@Data
public class Expense {
    private BigDecimal amount;  // ✅ Precision guaranteed
}

// Validation ensures proper decimal format
@Digits(integer = 10, fraction = 2, message = "Amount must have at most 2 decimal places")
private BigDecimal amount;
```

**Why BigDecimal:**
- ✅ Arbitrary precision decimal arithmetic
- ✅ No rounding errors in financial calculations
- ✅ Standard for monetary values in Java

---

### 3. In-Memory Storage Design

**Choice:** ConcurrentHashMap + CopyOnWriteArrayList

**Structure:**
```java
// Fast O(1) idempotency lookups
private final Map<String, Expense> idempotencyMap = new ConcurrentHashMap<>();

// Ordered storage with deterministic retrieval
private final List<Expense> expenses = new CopyOnWriteArrayList<>();
```

**Why This Design:**

**ConcurrentHashMap:**
- Thread-safe without external synchronization
- O(1) lookup for idempotency checks
- High-performance concurrent reads and writes

**CopyOnWriteArrayList:**
- Thread-safe for concurrent reads (our common case)
- Maintains insertion order (deterministic retrieval)
- Safe iteration without ConcurrentModificationException
- Trade-off: O(n) writes acceptable for expense creation frequency

**Thread Safety:**
```java
public synchronized Expense save(Expense expense) {
    // synchronized prevents race between check and insert
    Expense existing = idempotencyMap.get(expense.getClientRequestId());
    if (existing != null) {
        return existing;
    }
    // Atomic: check + insert as one operation
    idempotencyMap.put(expense.getClientRequestId(), expense);
    expenses.add(expense);
    return expense;
}
```

**Interface-Based Design:**
```java
public interface ExpenseStorage {
    Optional<Expense> findByClientRequestId(String clientRequestId);
    Expense save(Expense expense);
    List<Expense> findAll(String category);
}
```

**Easy Database Migration:**
```java
// Current: In-memory
@Repository
public class InMemoryExpenseStorage implements ExpenseStorage { }

// Future: JPA (no business logic changes needed)
@Repository
public class JpaExpenseStorage implements ExpenseStorage {
    @Autowired
    private ExpenseRepository repository;
    
    public Expense save(Expense expense) {
        return repository.save(expense);
    }
}
```

---

### 4. Clean Architecture (Separation of Concerns)

**Layered Structure:**
```
Controller (HTTP) → Service (Business Logic) → Storage (Persistence)
```

**Why:**
- ✅ **Testability:** Each layer can be unit tested independently
- ✅ **Maintainability:** Changes in one layer don't affect others
- ✅ **Clarity:** Each class has a single responsibility
- ✅ **Flexibility:** Easy to swap implementations (e.g., storage)

**Example Flow:**
```
1. ExpenseController receives HTTP request
2. Validates input (@Valid annotation)
3. Delegates to ExpenseService
4. ExpenseService applies business logic
5. Calls ExpenseStorage to persist
6. Returns result to controller
7. Controller formats HTTP response
```

---

### 5. Stable Deterministic Sorting

**Requirement:** Sort must be consistent across requests

**Implementation:**
```java
private List<Expense> sortByDateDescending(List<Expense> expenses) {
    return expenses.stream()
            .sorted(Comparator
                    .comparing(Expense::getDate).reversed()  // Primary: date desc
                    .thenComparing(Comparator.comparing(Expense::getCreatedAt).reversed()))  // Tie-breaker
            .toList();
}
```

**Why Two-Level Sort:**
- Primary: `date` (user-visible sort order)
- Secondary: `createdAt` (ensures expenses on same date have consistent order)
- Result: Same input always produces same output (deterministic)

---

## Trade-offs

### What We Chose (and Why)

✅ **In-memory storage instead of database**
- **Reason:** Timeboxed exercise - focus on correctness, not infrastructure
- **Trade-off:** Data lost on restart
- **Acceptable:** For this demo/exercise
- **Migration path:** Interface-based design allows easy database swap

✅ **CopyOnWriteArrayList instead of ArrayList**
- **Reason:** Thread safety for concurrent reads (common case)
- **Trade-off:** O(n) writes vs O(1) for ArrayList
- **Acceptable:** Expense creation is infrequent compared to reads

✅ **BigDecimal instead of Double**
- **Reason:** Precision is non-negotiable for money
- **Trade-off:** Slightly more verbose code
- **Worth it:** No floating-point errors in financial calculations

✅ **Synchronized save() instead of lock-free algorithm**
- **Reason:** Simplicity and correctness
- **Trade-off:** Performance under extreme concurrent writes
- **Acceptable:** Expense creation is not high-frequency enough to matter

✅ **No pagination**
- **Reason:** Timeboxed - focus on core functionality
- **Trade-off:** Performance with large datasets
- **Acceptable:** Can be added later without changing API contract

---

## How to Run Locally

### Prerequisites

- **Java 17** or higher
- **Maven 3.8+**
- **Node.js 18+** and **npm**

---

### Backend (Spring Boot)

1. **Navigate to backend directory:**
   ```bash
   cd backend
   ```

2. **Build the project:**
   ```bash
   mvn clean install
   ```

3. **Run the application:**
   ```bash
   mvn spring-boot:run
   ```

4. **Verify it's running:**
   ```bash
   curl http://localhost:8080/expenses/health
   ```

   Expected response:
   ```json
   {
     "status": "UP",
     "timestamp": "2024-01-15T10:30:00Z",
     "expenseCount": 0
   }
   ```

**Backend runs on:** `http://localhost:8080`

---

### Frontend (React + Vite)

1. **Navigate to frontend directory:**
   ```bash
   cd frontend
   ```

2. **Install dependencies:**
   ```bash
   npm install
   ```

3. **Start development server:**
   ```bash
   npm run dev
   ```

4. **Open in browser:**
   ```
   http://localhost:3000
   ```

**Frontend runs on:** `http://localhost:3000`

---

### Quick Start (Both Together)

**Terminal 1 - Backend:**
```bash
cd backend
mvn spring-boot:run
```

**Terminal 2 - Frontend:**
```bash
cd frontend
npm install
npm run dev
```

**Access the app:** http://localhost:3000

---

## API Documentation

### POST /expenses

Create a new expense (idempotent).

**Request:**
```json
{
  "amount": 100.50,
  "category": "Food",
  "description": "Lunch at cafe",
  "date": "2024-01-15",
  "clientRequestId": "1705320000000-abc123"
}
```

**Response (201 Created):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "amount": "100.50",
  "category": "Food",
  "description": "Lunch at cafe",
  "date": "2024-01-15",
  "createdAt": "2024-01-15T10:30:00Z",
  "clientRequestId": "1705320000000-abc123"
}
```

**Validation Errors (400 Bad Request):**
```json
{
  "error": "Validation failed",
  "validationErrors": {
    "amount": "Amount must be greater than 0",
    "category": "Category is required"
  }
}
```

---

### GET /expenses

Retrieve expenses with optional filtering and sorting.

**Query Parameters:**
- `category` (optional) - Filter by category
- `sort` (optional) - Sort order (`date_desc` for newest first)

**Examples:**

Get all expenses:
```
GET /expenses
```

Filter by category:
```
GET /expenses?category=Food
```

Sort by date (newest first):
```
GET /expenses?sort=date_desc
```

Combined:
```
GET /expenses?category=Food&sort=date_desc
```

**Response (200 OK):**
```json
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "amount": "100.50",
    "category": "Food",
    "description": "Lunch at cafe",
    "date": "2024-01-15",
    "createdAt": "2024-01-15T10:30:00Z",
    "clientRequestId": "1705320000000-abc123"
  }
]
```

---

## Project Structure

```
expense-tracker/
├── backend/                          # Spring Boot application
│   ├── src/main/java/com/expensetracker/
│   │   ├── ExpenseTrackerApplication.java    # Main entry point
│   │   ├── controller/
│   │   │   └── ExpenseController.java        # HTTP layer
│   │   ├── service/
│   │   │   └── ExpenseService.java           # Business logic
│   │   ├── storage/
│   │   │   ├── ExpenseStorage.java           # Storage interface
│   │   │   └── InMemoryExpenseStorage.java   # In-memory implementation
│   │   ├── model/
│   │   │   └── Expense.java                  # Domain model
│   │   └── dto/
│   │       └── CreateExpenseRequest.java     # Input DTO
│   ├── src/main/resources/
│   │   └── application.properties            # Configuration
│   └── pom.xml                               # Maven dependencies
│
├── frontend/                         # React application
│   ├── src/
│   │   ├── components/
│   │   │   ├── ExpenseForm.jsx              # Expense creation form
│   │   │   ├── ExpenseForm.css
│   │   │   ├── ExpenseList.jsx              # Expense display & filters
│   │   │   └── ExpenseList.css
│   │   ├── api/
│   │   │   └── expenseApi.js                # Backend API calls
│   │   ├── utils/
│   │   │   └── idGenerator.js               # Client request ID generation
│   │   ├── App.jsx                          # Main app component
│   │   ├── App.css
│   │   ├── main.jsx                         # React entry point
│   │   └── index.css
│   ├── index.html
│   ├── vite.config.js
│   └── package.json
│
└── README.md                         # This file
```

---

## Testing the Idempotency

### Manual Test: Duplicate Prevention

1. **Start both backend and frontend**

2. **Create an expense**
   - Amount: 100.00
   - Category: Food
   - Date: Today
   - Click "Add Expense"

3. **Immediately click "Add Expense" again** (before form resets)
   - Result: Only ONE expense created
   - Backend log shows: "Expense with clientRequestId ... already exists"

4. **Check the expense list**
   - Should see only 1 expense, not 2

### Curl Test: Retry Scenario

```bash
# Create expense with specific clientRequestId
REQUEST_ID="test-$(date +%s)"

# First request
curl -X POST http://localhost:8080/expenses \
  -H "Content-Type: application/json" \
  -d "{
    \"amount\": 50.00,
    \"category\": \"Transport\",
    \"description\": \"Taxi\",
    \"date\": \"2024-01-15\",
    \"clientRequestId\": \"$REQUEST_ID\"
  }"

# Retry with same ID (simulating network retry)
curl -X POST http://localhost:8080/expenses \
  -H "Content-Type: application/json" \
  -d "{
    \"amount\": 50.00,
    \"category\": \"Transport\",
    \"description\": \"Taxi\",
    \"date\": \"2024-01-15\",
    \"clientRequestId\": \"$REQUEST_ID\"
  }"

# Both requests return the SAME expense (same ID)
# No duplicate created
```

---

## Future Enhancements (Out of Scope)

These were intentionally not implemented due to timeboxing:

- ❌ **Database persistence** (PostgreSQL, MySQL)
- ❌ **Authentication & authorization**
- ❌ **Pagination** for large datasets
- ❌ **Delete/Edit expenses**
- ❌ **Export to CSV/PDF**
- ❌ **Charts and analytics**
- ❌ **Multi-currency support**
- ❌ **Budget tracking**
- ❌ **Recurring expenses**

**Migration to Database:**
```java
// Just swap the implementation
@Repository
public class JpaExpenseStorage implements ExpenseStorage {
    @Autowired
    private ExpenseRepository repository;
    
    @Override
    public Expense save(Expense expense) {
        // Add unique constraint on clientRequestId in DB
        return repository.save(expense);
    }
}
```

---

## What I Optimized For

✅ **Correctness under retries** - Idempotency guarantees no duplicates  
✅ **Data integrity** - BigDecimal for money, validation on input  
✅ **Clarity of design** - Clean separation, readable code, good names  
✅ **Ease of future extension** - Interface-based storage, layered architecture  
✅ **Thread safety** - ConcurrentHashMap, synchronized critical sections  
✅ **Deterministic behavior** - Stable sorting, consistent ordering  

---

## What I Did NOT Optimize For

❌ **UI polish** - Minimal CSS, functional not fancy  
❌ **Feature richness** - Only core functionality  
❌ **Extreme performance** - Good enough for expected load  
❌ **Production deployment** - No Docker, K8s, monitoring, etc.  

---

## Key Learnings / Decisions

1. **Idempotency is hard but essential** - Client-generated IDs are the right choice for RESTful APIs

2. **Money requires BigDecimal** - No shortcuts, floats are never acceptable

3. **In-memory can be production-quality** - With proper synchronization and clear trade-offs

4. **Interfaces enable flexibility** - Storage interface makes DB migration trivial

5. **Validation at the edge** - Jakarta validation catches bad input before business logic

6. **Thread safety is not optional** - Even simple apps need concurrent request handling

---

## Contact / Questions

This project demonstrates production-minded engineering under time constraints. The focus was on:
- Correctness over features
- Clarity over cleverness
- Extension over completeness

Built with intentional trade-offs and clean architecture.
